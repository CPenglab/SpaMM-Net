import os
os.environ['CUBLAS_WORKSPACE_CONFIG'] = ':4096:8'

import torch
from .utils import preprocessing, adata_const, set_random_seed
from .model import SpaMM
from .test_scr import load_test_data

def run_spamm(
    adata, scale = 3, epochs = 600, lr = .001,
    lr_step = [100, 200], gamma = .1,
    recon_w = None, scales_w = [.1, .2, .2],
    total_w = None, top_align_w = 0.1, weight_decay = 1e-4,
    rtn_model = False, device = None, acc_ctrl = True
):
    """Run spamm.

    Args:
        adata (sc.AnnData): AnnData generated by adata_const().
        scale (int, optional): Number of scales. Defaults to 3.
        epochs (int, optional): Training epochs. Defaults to 600.
        lr (float, optional): learning rate. Defaults to .001.
        lr_step (list, optional): List of steps for learning rate (lr) decay. Defaults to [100, 200].
        gamma (float, optional): Decay factor of the learning rate in MultiStepLR. Defaults to .1.
        recon_w (list, optional): Weights of reconstruction loss. Defaults to None.
        scales_w (list, optional): Weights of scale-level consistency losses. Defaults to [.1, .2, .2].
        total_w (list, optional):Weights for reconstruction, scale-level consistency, and global-level consistency. Defaults to None.
        top_align_w (float, optional): Weight of inner-layer alignment loss. Defaults to 0.1.
        weight_decay (float, optional): Parameter weight_decay in Adam. Defaults to 1e-4.
        rtn_model (bool, optional): Whether to return the model. Defaults to False.
        device (str, optional): The device is used to training. Defaults to None.
        acc_ctrl (bool, optional): Sets whether PyTorch operations must use “deterministic” algorithms. Defaults to False.

    Returns:
        dict: Extracted features.
    """
    sp_net = torch.tensor(adata.uns["sp_net"], dtype = torch.int64)
    om1_net = torch.tensor(adata.uns["om1_net"], dtype = torch.int64)
    om2_net = torch.tensor(adata.uns["om2_net"], dtype = torch.int64)
    spmm = SpaMM(
        in_ch = adata.X.shape[-1],
        scales = scale,
        device = device
    )
    spmm.fit(
        omics = torch.tensor(adata.X),
        sp_net = sp_net,
        om1_net = om1_net,
        om2_net = om2_net,
        epochs = epochs,
        lr = lr, lr_step = lr_step, gamma = gamma,
        recon_w = recon_w, scales_w = scales_w, total_w = total_w,
        top_align_w = top_align_w, weight_decay = weight_decay
    )

    torch.use_deterministic_algorithms(acc_ctrl, warn_only=False)

    out = spmm.trans(
        omics = torch.tensor(adata.X),
        sp_net = sp_net,
        om1_net = om1_net,
        om2_net = om2_net
    )
    
    if rtn_model:
        return [out, spmm]
    else:
        return out
